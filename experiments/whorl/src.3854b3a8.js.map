{"version":3,"sources":["../node_modules/hyperapp/src/index.js","../node_modules/arcsecond/index.mjs","../node_modules/tie-dye/hueToRgb.js","../node_modules/tie-dye/hslToRgb.js","../node_modules/tie-dye/rgbToHex.js","../node_modules/tie-dye/hslToHex.js","../node_modules/hashbow/index.js","index.js"],"names":["RECYCLED_NODE","LAZY_NODE","TEXT_NODE","EMPTY_OBJ","EMPTY_ARR","map","isArray","Array","defer","requestAnimationFrame","setTimeout","createClass","obj","out","length","tmp","k","merge","a","b","batch","list","reduce","item","concat","isSameAction","shouldRestart","patchSubs","oldSubs","newSubs","dispatch","oldSub","newSub","i","subs","push","patchProperty","node","key","oldValue","newValue","listener","isSvg","setProperty","actions","slice","toLowerCase","addEventListener","removeEventListener","removeAttribute","setAttribute","createNode","vdom","ns","props","type","document","createTextNode","name","createElementNS","is","createElement","len","children","appendChild","getVNode","getKey","patch","parent","oldVNode","newVNode","nodeValue","insertBefore","removeChild","tmpVKid","oldVKid","oldKey","newKey","oldVProps","newVProps","oldVKids","newVKids","oldHead","newHead","oldTail","newTail","keyed","newKeyed","propsChanged","getTextVNode","createTextVNode","lazy","view","createVNode","value","undefined","recycleNode","nodeType","nodeName","call","childNodes","Lazy","h","rest","arguments","pop","app","state","lock","subscriptions","event","setState","newState","render","middleware","action","fx","parentNode","init","reDigit","reDigits","reLetter","reLetters","reWhitespaces","createParserState","target","data","isError","error","index","result","updateError","updateResult","updateData","updateParserState","Parser","p","prototype","run","targetString","resultState","fork","errorFn","successFn","fn","parserOfFunction","argumentState","fnState","errorMap","nextState","errorChain","nextParser","mapFromData","chainFromData","mapData","x","ap","chain","of","getData","setData","withData","parser","stateData","pipeParsers","parsers","composeParsers","reverse","tapParser","parse","decide","fail","errorMessage","succeedWith","either","coroutine","g","_","generator","step","nextValue","next","done","Error","many","results","many1","resState","mapTo","errorMapTo","char","c","TypeError","str","s","startsWith","regex","re","typeofre","Object","toString","match","digit","test","digits","letter","letters","anyOfString","includes","namedSequenceOf","pairedParsers","sequenceOf","sepBy","sepParser","valParser","valState","sepState","sepBy1","choice","between","leftParser","rightParser","everythingUntil","val","join","anythingExcept","lookAhead","possibly","skip","endOfInput","whitespace","optionalWhitespace","recursiveParser","parserThunk","takeRight","lParser","rParser","takeLeft","toPromise","Promise","reject","resolve","toValue","e","parseIndex","positiveNumber","A","parseInt","number","sign","diceNotationParser","numDice","die","offset","roll","sum","Math","floor","random","simpleDistribution","dieSize","dist","Map","set","addDistributions","y","xResult","xProbability","yResult","yProbability","get","offsetDistribution","newDist","probability","stats","lowerBound","upperBound","oneDieProbabilities","probabilities","percentage","toFixed","renderDistribution","elements","highest","fraction","width","height","style","fill","class","rollButton","dice","rolls","updateDice","text","console","log","rawDice","raw","renderRoll","color","onClick","onDiceInput","onInput","getElementById"],"mappings":"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","file":"src.3854b3a8.js","sourceRoot":"../src","sourcesContent":["var RECYCLED_NODE = 1\nvar LAZY_NODE = 2\nvar TEXT_NODE = 3\nvar EMPTY_OBJ = {}\nvar EMPTY_ARR = []\nvar map = EMPTY_ARR.map\nvar isArray = Array.isArray\nvar defer =\n  typeof requestAnimationFrame !== \"undefined\"\n    ? requestAnimationFrame\n    : setTimeout\n\nvar createClass = function(obj) {\n  var out = \"\"\n\n  if (typeof obj === \"string\") return obj\n\n  if (isArray(obj) && obj.length > 0) {\n    for (var k = 0, tmp; k < obj.length; k++) {\n      if ((tmp = createClass(obj[k])) !== \"\") {\n        out += (out && \" \") + tmp\n      }\n    }\n  } else {\n    for (var k in obj) {\n      if (obj[k]) {\n        out += (out && \" \") + k\n      }\n    }\n  }\n\n  return out\n}\n\nvar merge = function(a, b) {\n  var out = {}\n\n  for (var k in a) out[k] = a[k]\n  for (var k in b) out[k] = b[k]\n\n  return out\n}\n\nvar batch = function(list) {\n  return list.reduce(function(out, item) {\n    return out.concat(\n      !item || item === true\n        ? 0\n        : typeof item[0] === \"function\"\n        ? [item]\n        : batch(item)\n    )\n  }, EMPTY_ARR)\n}\n\nvar isSameAction = function(a, b) {\n  return isArray(a) && isArray(b) && a[0] === b[0] && typeof a[0] === \"function\"\n}\n\nvar shouldRestart = function(a, b) {\n  if (a !== b) {\n    for (var k in merge(a, b)) {\n      if (a[k] !== b[k] && !isSameAction(a[k], b[k])) return true\n      b[k] = a[k]\n    }\n  }\n}\n\nvar patchSubs = function(oldSubs, newSubs, dispatch) {\n  for (\n    var i = 0, oldSub, newSub, subs = [];\n    i < oldSubs.length || i < newSubs.length;\n    i++\n  ) {\n    oldSub = oldSubs[i]\n    newSub = newSubs[i]\n    subs.push(\n      newSub\n        ? !oldSub ||\n          newSub[0] !== oldSub[0] ||\n          shouldRestart(newSub[1], oldSub[1])\n          ? [\n              newSub[0],\n              newSub[1],\n              newSub[0](dispatch, newSub[1]),\n              oldSub && oldSub[2]()\n            ]\n          : oldSub\n        : oldSub && oldSub[2]()\n    )\n  }\n  return subs\n}\n\nvar patchProperty = function(node, key, oldValue, newValue, listener, isSvg) {\n  if (key === \"key\") {\n  } else if (key === \"style\") {\n    for (var k in merge(oldValue, newValue)) {\n      oldValue = newValue == null || newValue[k] == null ? \"\" : newValue[k]\n      if (k[0] === \"-\") {\n        node[key].setProperty(k, oldValue)\n      } else {\n        node[key][k] = oldValue\n      }\n    }\n  } else if (key[0] === \"o\" && key[1] === \"n\") {\n    if (\n      !((node.actions || (node.actions = {}))[\n        (key = key.slice(2).toLowerCase())\n      ] = newValue)\n    ) {\n      node.removeEventListener(key, listener)\n    } else if (!oldValue) {\n      node.addEventListener(key, listener)\n    }\n  } else if (!isSvg && key !== \"list\" && key in node) {\n    node[key] = newValue == null ? \"\" : newValue\n  } else if (\n    newValue == null ||\n    newValue === false ||\n    (key === \"class\" && !(newValue = createClass(newValue)))\n  ) {\n    node.removeAttribute(key)\n  } else {\n    node.setAttribute(key, newValue)\n  }\n}\n\nvar createNode = function(vdom, listener, isSvg) {\n  var ns = \"http://www.w3.org/2000/svg\"\n  var props = vdom.props\n  var node =\n    vdom.type === TEXT_NODE\n      ? document.createTextNode(vdom.name)\n      : (isSvg = isSvg || vdom.name === \"svg\")\n      ? document.createElementNS(ns, vdom.name, { is: props.is })\n      : document.createElement(vdom.name, { is: props.is })\n\n  for (var k in props) {\n    patchProperty(node, k, null, props[k], listener, isSvg)\n  }\n\n  for (var i = 0, len = vdom.children.length; i < len; i++) {\n    node.appendChild(\n      createNode(\n        (vdom.children[i] = getVNode(vdom.children[i])),\n        listener,\n        isSvg\n      )\n    )\n  }\n\n  return (vdom.node = node)\n}\n\nvar getKey = function(vdom) {\n  return vdom == null ? null : vdom.key\n}\n\nvar patch = function(parent, node, oldVNode, newVNode, listener, isSvg) {\n  if (oldVNode === newVNode) {\n  } else if (\n    oldVNode != null &&\n    oldVNode.type === TEXT_NODE &&\n    newVNode.type === TEXT_NODE\n  ) {\n    if (oldVNode.name !== newVNode.name) node.nodeValue = newVNode.name\n  } else if (oldVNode == null || oldVNode.name !== newVNode.name) {\n    node = parent.insertBefore(\n      createNode((newVNode = getVNode(newVNode)), listener, isSvg),\n      node\n    )\n    if (oldVNode != null) {\n      parent.removeChild(oldVNode.node)\n    }\n  } else {\n    var tmpVKid\n    var oldVKid\n\n    var oldKey\n    var newKey\n\n    var oldVProps = oldVNode.props\n    var newVProps = newVNode.props\n\n    var oldVKids = oldVNode.children\n    var newVKids = newVNode.children\n\n    var oldHead = 0\n    var newHead = 0\n    var oldTail = oldVKids.length - 1\n    var newTail = newVKids.length - 1\n\n    isSvg = isSvg || newVNode.name === \"svg\"\n\n    for (var i in merge(oldVProps, newVProps)) {\n      if (\n        (i === \"value\" || i === \"selected\" || i === \"checked\"\n          ? node[i]\n          : oldVProps[i]) !== newVProps[i]\n      ) {\n        patchProperty(node, i, oldVProps[i], newVProps[i], listener, isSvg)\n      }\n    }\n\n    while (newHead <= newTail && oldHead <= oldTail) {\n      if (\n        (oldKey = getKey(oldVKids[oldHead])) == null ||\n        oldKey !== getKey(newVKids[newHead])\n      ) {\n        break\n      }\n\n      patch(\n        node,\n        oldVKids[oldHead].node,\n        oldVKids[oldHead],\n        (newVKids[newHead] = getVNode(\n          newVKids[newHead++],\n          oldVKids[oldHead++]\n        )),\n        listener,\n        isSvg\n      )\n    }\n\n    while (newHead <= newTail && oldHead <= oldTail) {\n      if (\n        (oldKey = getKey(oldVKids[oldTail])) == null ||\n        oldKey !== getKey(newVKids[newTail])\n      ) {\n        break\n      }\n\n      patch(\n        node,\n        oldVKids[oldTail].node,\n        oldVKids[oldTail],\n        (newVKids[newTail] = getVNode(\n          newVKids[newTail--],\n          oldVKids[oldTail--]\n        )),\n        listener,\n        isSvg\n      )\n    }\n\n    if (oldHead > oldTail) {\n      while (newHead <= newTail) {\n        node.insertBefore(\n          createNode(\n            (newVKids[newHead] = getVNode(newVKids[newHead++])),\n            listener,\n            isSvg\n          ),\n          (oldVKid = oldVKids[oldHead]) && oldVKid.node\n        )\n      }\n    } else if (newHead > newTail) {\n      while (oldHead <= oldTail) {\n        node.removeChild(oldVKids[oldHead++].node)\n      }\n    } else {\n      for (var i = oldHead, keyed = {}, newKeyed = {}; i <= oldTail; i++) {\n        if ((oldKey = oldVKids[i].key) != null) {\n          keyed[oldKey] = oldVKids[i]\n        }\n      }\n\n      while (newHead <= newTail) {\n        oldKey = getKey((oldVKid = oldVKids[oldHead]))\n        newKey = getKey(\n          (newVKids[newHead] = getVNode(newVKids[newHead], oldVKid))\n        )\n\n        if (\n          newKeyed[oldKey] ||\n          (newKey != null && newKey === getKey(oldVKids[oldHead + 1]))\n        ) {\n          if (oldKey == null) {\n            node.removeChild(oldVKid.node)\n          }\n          oldHead++\n          continue\n        }\n\n        if (newKey == null || oldVNode.type === RECYCLED_NODE) {\n          if (oldKey == null) {\n            patch(\n              node,\n              oldVKid && oldVKid.node,\n              oldVKid,\n              newVKids[newHead],\n              listener,\n              isSvg\n            )\n            newHead++\n          }\n          oldHead++\n        } else {\n          if (oldKey === newKey) {\n            patch(\n              node,\n              oldVKid.node,\n              oldVKid,\n              newVKids[newHead],\n              listener,\n              isSvg\n            )\n            newKeyed[newKey] = true\n            oldHead++\n          } else {\n            if ((tmpVKid = keyed[newKey]) != null) {\n              patch(\n                node,\n                node.insertBefore(tmpVKid.node, oldVKid && oldVKid.node),\n                tmpVKid,\n                newVKids[newHead],\n                listener,\n                isSvg\n              )\n              newKeyed[newKey] = true\n            } else {\n              patch(\n                node,\n                oldVKid && oldVKid.node,\n                null,\n                newVKids[newHead],\n                listener,\n                isSvg\n              )\n            }\n          }\n          newHead++\n        }\n      }\n\n      while (oldHead <= oldTail) {\n        if (getKey((oldVKid = oldVKids[oldHead++])) == null) {\n          node.removeChild(oldVKid.node)\n        }\n      }\n\n      for (var i in keyed) {\n        if (newKeyed[i] == null) {\n          node.removeChild(keyed[i].node)\n        }\n      }\n    }\n  }\n\n  return (newVNode.node = node)\n}\n\nvar propsChanged = function(a, b) {\n  for (var k in a) if (a[k] !== b[k]) return true\n  for (var k in b) if (a[k] !== b[k]) return true\n}\n\nvar getTextVNode = function(node) {\n  return typeof node === \"object\" ? node : createTextVNode(node)\n}\n\nvar getVNode = function(newVNode, oldVNode) {\n  return newVNode.type === LAZY_NODE\n    ? ((!oldVNode ||\n        (oldVNode.type !== LAZY_NODE ||\n          propsChanged(oldVNode.lazy, newVNode.lazy))) &&\n        ((oldVNode = getTextVNode(newVNode.lazy.view(newVNode.lazy))).lazy =\n          newVNode.lazy),\n      oldVNode)\n    : newVNode\n}\n\nvar createVNode = function(name, props, children, node, key, type) {\n  return {\n    name: name,\n    props: props,\n    children: children,\n    node: node,\n    type: type,\n    key: key\n  }\n}\n\nvar createTextVNode = function(value, node) {\n  return createVNode(value, EMPTY_OBJ, EMPTY_ARR, node, undefined, TEXT_NODE)\n}\n\nvar recycleNode = function(node) {\n  return node.nodeType === TEXT_NODE\n    ? createTextVNode(node.nodeValue, node)\n    : createVNode(\n        node.nodeName.toLowerCase(),\n        EMPTY_OBJ,\n        map.call(node.childNodes, recycleNode),\n        node,\n        undefined,\n        RECYCLED_NODE\n      )\n}\n\nexport var Lazy = function(props) {\n  return {\n    lazy: props,\n    type: LAZY_NODE\n  }\n}\n\nexport var h = function(name, props) {\n  for (var vdom, rest = [], children = [], i = arguments.length; i-- > 2; ) {\n    rest.push(arguments[i])\n  }\n\n  while (rest.length > 0) {\n    if (isArray((vdom = rest.pop()))) {\n      for (var i = vdom.length; i-- > 0; ) {\n        rest.push(vdom[i])\n      }\n    } else if (vdom === false || vdom === true || vdom == null) {\n    } else {\n      children.push(getTextVNode(vdom))\n    }\n  }\n\n  props = props || EMPTY_OBJ\n\n  return typeof name === \"function\"\n    ? name(props, children)\n    : createVNode(name, props, children, undefined, props.key)\n}\n\nexport var app = function(props) {\n  var state = {}\n  var lock = false\n  var view = props.view\n  var node = props.node\n  var vdom = node && recycleNode(node)\n  var subscriptions = props.subscriptions\n  var subs = []\n\n  var listener = function(event) {\n    dispatch(this.actions[event.type], event)\n  }\n\n  var setState = function(newState) {\n    if (state !== newState) {\n      state = newState\n      if (subscriptions) {\n        subs = patchSubs(subs, batch([subscriptions(state)]), dispatch)\n      }\n      if (view && !lock) defer(render, (lock = true))\n    }\n    return state\n  }\n\n  var dispatch = (props.middleware ||\n    function(obj) {\n      return obj\n    })(function(action, props) {\n    return typeof action === \"function\"\n      ? dispatch(action(state, props))\n      : isArray(action)\n      ? typeof action[0] === \"function\" || isArray(action[0])\n        ? dispatch(\n            action[0],\n            typeof action[1] === \"function\" ? action[1](props) : action[1]\n          )\n        : (batch(action.slice(1)).map(function(fx) {\n            fx && fx[0](dispatch, fx[1])\n          }, setState(action[0])),\n          state)\n      : setState(action)\n  })\n\n  var render = function() {\n    lock = false\n    node = patch(\n      node.parentNode,\n      node,\n      vdom,\n      (vdom = getTextVNode(view(state))),\n      listener\n    )\n  }\n\n  dispatch(props.init)\n}\n","// data ParserState e a s\n// data Parser e a s = { p: ParserState e a s }\n// data StateData a s = { result: a, data: s }\n// data ParsingResult e a = Ok a | Error e\n\n// Caching compiled regexs for better performance\nconst reDigit = /[0-9]/;\nconst reDigits = /^[0-9]+/;\nconst reLetter = /[a-zA-Z]/;\nconst reLetters = /^[a-zA-Z]+/;\nconst reWhitespaces = /^\\s+/;\n\n//    createParserState :: x -> s -> ParserState e a s\nconst createParserState = (target, data = null) => ({\n  isError: false,\n  error: null,\n  target,\n  data,\n  index: 0,\n  result: null\n});\n\n//    updateError :: (ParserState e a s, f) -> ParserState f a s\nconst updateError = (state, error) => ({ ...state, isError: true, error });\n\n//    updateResult :: (ParserState e a s, b) -> ParserState e b s\nconst updateResult = (state, result) => ({ ...state, result });\n\n//    updateData :: (ParserState e a s, t) -> ParserState e b t\nconst updateData = (state, data) => ({ ...state, data });\n\n//    updateResult :: (ParserState e a s, b, Integer) -> ParserState e b s\nconst updateParserState = (state, result, index) => ({ ...state, result, index });\n\n//         data Parser e a s\nexport function Parser(p) {\n  this.p = p;\n};\n\n//               run :: Parser e a s ~> x -> Either e a\nParser.prototype.run = function Parser$run(targetString) {\n  const state = createParserState(targetString, null);\n\n  const resultState = this.p(state);\n\n  if (resultState.isError) {\n    return {\n      isError: true,\n      error: resultState.error,\n      index: resultState.index,\n      data: resultState.data\n    };\n  }\n\n  return {\n    isError: false,\n    result: resultState.result,\n    index: resultState.index,\n    data: resultState.data\n  };\n};\n\n//               fork :: Parser e a s ~> x -> (e -> ParserState e a s -> f) -> (a -> ParserState e a s -> b)\nParser.prototype.fork = function Parser$run(targetString, errorFn, successFn) {\n  const state = createParserState(targetString);\n  const newState = this.p(state);\n\n  if (newState.isError) {\n    return errorFn(newState.error, newState);\n  }\n\n  return successFn(newState.result, newState);\n};\n\n//               map :: Parser e a s ~> (a -> b) -> Parser e b s\nParser.prototype['fantasy-land/map'] = function Parser$map(fn) {\n  const p = this.p;\n  return new Parser(function Parser$map$state (state) {\n    const newState = p(state);\n    if (newState.isError) return newState;\n    return updateResult(newState, fn(newState.result));\n  });\n};\n\n//                chain :: Parser e a s ~> (a -> Parser e b s) -> Parser e b s\nParser.prototype['fantasy-land/chain'] = function Parser$chain(fn) {\n  const p = this.p;\n  return new Parser(function Parser$chain$state(state) {\n    const newState = p(state);\n    if (newState.isError) return newState;\n    return fn(newState.result).p(newState);\n  });\n};\n\n//               ap :: Parser e a s ~> Parser e (a -> b) s -> Parser e b s\nParser.prototype['fantasy-land/ap'] = function Parser$ap(parserOfFunction) {\n  const p = this.p;\n  return new Parser(function Parser$ap$state(state) {\n    if (state.isError) return state;\n\n    const argumentState = p(state);\n    if (argumentState.isError) return argumentState;\n\n    const fnState = parserOfFunction.p(argumentState);\n    if (fnState.isError) return fnState;\n\n    return updateResult(fnState, fnState.result(argumentState.result));\n  });\n};\n\n//               errorMap :: Parser e a s ~> (e -> f) -> Parser f a s\nParser.prototype.errorMap = function Parser$errorMap(fn) {\n  const p = this.p;\n  return new Parser(function Parser$errorMap$state(state) {\n    const nextState = p(state);\n    if (!nextState.isError) return nextState;\n\n    return updateError(nextState, fn(nextState.error, nextState.index, nextState.data));\n  });\n};\n\n//               errorChain :: Parser e a s ~> ((e, Integer, s) -> Parser f a s) -> Parser f a s\nParser.prototype.errorChain = function Parser$errorMap(fn) {\n  const p = this.p;\n  return new Parser(function Parser$errorMap$state(state) {\n    const nextState = p(state);\n    if (nextState.isError) {\n      const {error, index, data} = nextState;\n      const nextParser = fn({error, index, data});\n      return nextParser.p({ ...nextState, isError: false });\n    }\n    return nextState;\n  });\n};\n\n//               mapFromData :: Parser e a s ~> (StateData a s -> b) -> Parser e b s\nParser.prototype.mapFromData = function Parser$mapFromData(fn) {\n  const p = this.p;\n  return new Parser(function Parser$mapFromData$state (state) {\n    const newState = p(state);\n    if (newState.error) return newState;\n    return updateResult(newState, fn({result: newState.result, data: newState.data}));\n  });\n};\n\n//               chainFromData :: Parser e a s ~> (StateData a s -> Parser f b t) -> Parser f b t\nParser.prototype.chainFromData = function Parser$chainFromData(fn) {\n  const p = this.p;\n  return new Parser(function Parser$chainFromData$state(state) {\n    const newState = p(state);\n    if (newState.error) return newState;\n    return fn({result: newState.result, data: newState.data}).p(newState);\n  });\n};\n\n//               mapData :: Parser e a s ~> (s -> t) -> Parser e a t\nParser.prototype.mapData = function mapData(fn) {\n  const p = this.p;\n  return new Parser(function mapData$state(state) {\n    const newState = p(state);\n    return updateData(newState, fn(newState.data));\n  });\n};\n\n//                   of :: a -> Parser e a s\nParser['fantasy-land/of'] = function (x) {\n  return new Parser(state => updateResult(state, x));\n};\n\nParser.prototype.map = Parser.prototype['fantasy-land/map'];\nParser.prototype.ap = Parser.prototype['fantasy-land/ap'];\nParser.prototype.chain = Parser.prototype['fantasy-land/chain'];\nParser.of = Parser['fantasy-land/of'];\n\n//           getData :: Parser e a s\nexport const getData = new Parser(function getData$state(state) {\n  if (state.isError) return state;\n  return updateResult(state, state.data);\n});\n\n//           setData :: t -> Parser e a t\nexport const setData = function setData(x) {\n  return new Parser(function setData$state(state) {\n    if (state.isError) return state;\n    return updateData(state, x)\n  });\n};\n\n//           mapData :: (s -> t) -> Parser e a t\nexport const mapData = function mapData(fn) {\n  return new Parser(function mapData$state(state) {\n    if (state.isError) return state;\n    return updateData(state, fn(state.data));\n  });\n};\n\n//           withData :: Parser e a x -> s -> Parser e a s\nexport const withData = function withData(parser) {\n  return function withData$parser(stateData) {\n    return setData(stateData).chain(() => parser);\n  };\n};\n\n//           pipeParsers :: [Parser * * *] -> Parser * * *\nexport const pipeParsers = function pipeParsers (parsers) {\n  return new Parser(function pipeParsers$state (state) {\n    let nextState = state;\n    for (const parser of parsers) {\n      nextState = parser.p(nextState);\n    }\n    return nextState;\n  });\n};\n\n//           composeParsers :: [Parser * * *] -> Parser * * *\nexport const composeParsers = function composeParsers(parsers) {\n  return new Parser(function composeParsers$state(state) {\n    return pipeParsers ([...parsers].reverse()).p(state);\n  });\n};\n\n//           tapParser :: (a => ()) -> Parser e a s\nexport const tapParser = function tapParser(fn) {\n  return new Parser(function tapParser$state(state) {\n    fn(state);\n    return state;\n  });\n};\n\n//           parse :: Parser e a s -> String -> Either e a\nexport const parse = function parse(parser) {\n  return function parse$targetString(targetString) {\n    return parser.run(targetString);\n  };\n};\n\n//           decide :: (a -> Parser e b s) -> Parser e b s\nexport const decide = function decide(fn) {\n  return new Parser(function decide$state(state) {\n    if (state.isError) return state;\n    const parser = fn(state.result);\n    return parser.p(state);\n  });\n};\n\n//           fail :: e -> Parser e a s\nexport const fail = function fail(errorMessage) {\n  return new Parser(function fail$state(state) {\n    if (state.isError) return state;\n    return updateError(state, errorMessage);\n  });\n};\n\n//           succeedWith :: a -> Parser e a s\nexport const succeedWith = Parser.of;\n\n//           either :: Parser e a s -> Parser e (Either e a) s\nexport const either = function either(parser) {\n  return new Parser(function either$state(state) {\n    if (state.isError) return state;\n\n    const nextState = parser.p(state);\n\n    return updateResult({...nextState, isError: false}, {\n      isError: nextState.isError,\n      value: nextState.isError ? nextState.error : nextState.result\n    });\n  });\n}\n\n//           coroutine :: (() -> Iterator (Parser e a s)) -> Parser e a s\nexport const coroutine = function coroutine(g) {\n  return Parser.of().chain(_ => {\n    const generator = g();\n\n    const step = (nextValue) => {\n      const result = generator.next(nextValue);\n      const value = result.value;\n      const done = result.done;\n\n      if (!done && (!value || typeof value.chain !== 'function')) {\n        throw new Error(`[coroutine] yielded values must be Parsers, got ${result.value}.`);\n      }\n\n      return done\n        ? Parser.of(value)\n        : value.chain(step);\n    };\n\n    return step();\n  });\n};\n\n//           many :: Parser e s a -> Parser e s [a]\nexport const many = function many(parser) {\n  return new Parser(function many$state(state) {\n    if (state.isError) return state;\n\n    const results = [];\n    let nextState = state;\n\n    while (true) {\n      const out = parser.p(nextState);\n\n      if (out.isError) {\n        break;\n      } else {\n        nextState = out;\n        results.push(nextState.result);\n\n        if (nextState.index >= nextState.target.length) {\n          break;\n        }\n      }\n    }\n\n    return updateResult(nextState, results);\n  });\n};\n\n//           many1 :: Parser e s a -> Parser e s [a]\nexport const many1 = function many1(parser) {\n  return new Parser(function many1$state(state) {\n    if (state.isError) return state;\n\n    const resState = many (parser).p(state);\n    if (resState.result.length) return resState;\n\n    return updateError(state, `ParseError 'many1' (position ${state.index}): Expecting to match at least one value`);\n  });\n};\n\n//           mapTo :: (a -> b) -> Parser e b s\nexport const mapTo = function mapTo(fn) {\n  return new Parser(function mapTo$state(state) {\n    if (state.isError) return state;\n    return updateResult(state, fn(state.result));\n  });\n};\n\n//           errorMapTo :: (ParserState e a s -> f) -> Parser f a s\nexport const errorMapTo = fn => new Parser(state => {\n  if (!state.isError) return state;\n  return updateError(state, fn(state.error, state.index, state.data));\n});\n\n//           char :: Char -> Parser e Char s\nexport const char = function char(c) {\n  if (!c || c.length !== 1) {\n    throw new TypeError (`char must be called with a single character, but got ${c}`);\n  }\n\n  return new Parser(function char$state (state) {\n    if (state.isError) return state;\n\n    const {target, index} = state;\n    if (index < target.length) {\n      return (target[index] === c)\n        ? updateParserState(state, c, index + 1)\n        : updateError(state, `ParseError (position ${index}): Expecting character '${c}', got '${target[index]}'`);\n    }\n    return updateError(state, `ParseError (position ${index}): Expecting character '${c}', but got end of input.`);\n  });\n};\n\n//           str :: String -> Parser e String s\nexport const str = function str(s) {\n  if (!s || s.length < 1) {\n    throw new TypeError (`str must be called with a string with length > 1, but got ${s}`);\n  }\n\n  return new Parser(function str$state (state) {\n    const {target, index} = state;\n    const rest = target.slice(index);\n\n    if (rest.length >= 1) {\n      return (rest.startsWith(s))\n        ? updateParserState(state, s, index + s.length)\n        : updateError(state, `ParseError (position ${index}): Expecting string '${s}', got '${rest.slice(0, s.length)}...'`);\n    }\n\n    return updateError(state, `ParseError (position ${index}): Expecting string '${s}', but got end of input.`);\n  });\n};\n\n//           regex :: RegExp -> Parser e String s\nexport const regex = function regex(re) {\n  const typeofre = Object.prototype.toString.call(re);\n  if (typeofre !== '[object RegExp]') {\n    throw new TypeError (`regex must be called with a Regular Expression, but got ${typeofre}`);\n  }\n\n  if (re.toString()[1] !== '^') {\n    throw new Error(`regex parsers must contain '^' start assertion.`)\n  }\n\n  return new Parser(function regex$state(state) {\n    if (state.isError) return state;\n    const {target, index} = state;\n    const rest = target.slice(index);\n\n    if (rest.length >= 1) {\n      const match = rest.match(re);\n      return (match)\n        ? updateParserState(state, match[0], index + match[0].length)\n        : updateError(state, `ParseError (position ${index}): Expecting string matching '${re}', got '${rest.slice(0, 5)}...'`)\n    }\n    return updateError(state, `ParseError (position ${index}): Expecting string matching '${re}', but got end of input.`);\n  });\n};\n\n//           digit :: Parser e String s\nexport const digit = new Parser(function digit$state(state) {\n  if (state.isError) return state;\n\n  const {target, index} = state;\n\n  if (target.length > index) {\n    return (target.length && target[index] && reDigit.test(target[index]))\n      ? updateParserState(state, target[index], index + 1)\n      : updateError(state, `ParseError (position ${index}): Expecting digit, got '${target[index]}'`)\n  }\n  return updateError(state, `ParseError (position ${index}): Expecting digit, but got end of input.`);\n});\n\n//           digits :: Parser e String s\nexport const digits = regex(reDigits)\n  .errorMap((_, index) => `ParseError (position ${index}): Expecting digits`);\n\n//           letter :: Parser e Char s\nexport const letter = new Parser(function letter$state(state) {\n  if (state.isError) return state;\n\n  const {index, target} = state;\n\n  if (target.length > index) {\n    return (target.length && target[index] && reLetter.test(target[index]))\n      ? updateParserState(state, target[index], index + 1)\n      : updateError(state, `ParseError (position ${index}): Expecting letter, got '${target[index]}'`);\n  }\n\n  return updateError(state, `ParseError (position ${index}): Expecting letter, but got end of input.`);\n});\n\n//           letters :: Parser e String s\nexport const letters = regex(reLetters)\n  .errorMap((_, index) => `ParseError (position ${index}): Expecting letters`);\n\n//           anyOfString :: String -> Parser e Char s\nexport const anyOfString = function anyOfString(s) {\n  return new Parser(function anyOfString$state(state) {\n    if (state.isError) return state;\n\n    const {target, index} = state;\n\n    if (target.length > index) {\n      return (s.includes(target[index]))\n        ? updateParserState(state, target[index], index + 1)\n        : updateError(state, `ParseError (position ${index}): Expecting any of the string \"${s}\", got ${target[index]}`);\n    }\n    return updateError(state, `ParseError (position ${index}): Expecting any of the string \"${s}\", but got end of input.`);\n  });\n};\n\n//           namedSequenceOf :: [(String, Parser * * *)] -> Parser e (StrMap *) s\nexport const namedSequenceOf = function namedSequenceOf(pairedParsers) {\n  return new Parser(function namedSequenceOf$state(state) {\n    if (state.isError) return state;\n\n    const results = {};\n    let nextState = state;\n\n    for (const [key, parser] of pairedParsers) {\n      const out = parser.p(nextState);\n      if (out.isError) {\n        return out;\n      } else {\n        nextState = out;\n        results[key] = out.result;\n      }\n    }\n\n    return updateResult(nextState, results);\n  });\n};\n\n//           sequenceOf :: [Parser * * *] -> Parser * [*] *\nexport const sequenceOf = function sequenceOf(parsers) {\n  return new Parser(function sequenceOf$state(state) {\n    if (state.isError) return state;\n\n    const length = parsers.length;\n    const results = new Array(length);\n    let nextState = state;\n\n    for (let i = 0; i < length; i++) {\n      const out = parsers[i].p(nextState);\n\n      if (out.isError) {\n        return out;\n      } else {\n        nextState = out;\n        results[i] = out.result;\n      }\n    }\n\n    return updateResult(nextState, results);\n  });\n};\n\n//           sepBy :: Parser e a s -> Parser e b s -> Parser e [b] s\nexport const sepBy = function sepBy(sepParser) {\n  return function sepBy$valParser(valParser) {\n    return new Parser(function sepBy$valParser$state(state) {\n      if (state.isError) return state;\n\n      let nextState = state;\n      let error = null;\n      const results = [];\n\n      while (true) {\n        const valState = valParser.p(nextState);\n        const sepState = sepParser.p(valState);\n\n        if (valState.isError) {\n          error = valState;\n          break;\n        } else {\n          results.push(valState.result);\n        }\n\n        if (sepState.isError) {\n          nextState = valState;\n          break;\n        }\n\n        nextState = sepState;\n      }\n\n      if (error) {\n        if (results.length === 0) {\n          return updateResult(state, results)\n        }\n        return error;\n      }\n\n      return updateResult(nextState, results);\n    });\n  }\n};\n\n//           sepBy1 :: Parser e a s -> Parser e b s -> Parser e [b] s\nexport const sepBy1 = function sepBy1(sepParser) {\n  return function sepBy1$valParser(valParser) {\n    return new Parser(function sepBy1$valParser$state(state) {\n      if (state.isError) return state;\n\n      const out = sepBy(sepParser)(valParser).p(state);\n      if (out.isError) return out;\n      if (out.result.length === 0) {\n        return updateError(state, `ParseError 'sepBy1' (position ${state.index}): Expecting to match at least one separated value`);\n      }\n      return out;\n    });\n  }\n};\n\n//           choice :: [Parser * * *] -> Parser * * *\nexport const choice = function choice(parsers) {\n  return new Parser(function choice$state(state) {\n    if (state.isError) return state;\n\n    let error = null;\n    for (const parser of parsers) {\n      const out = parser.p(state);\n\n      if (!out.isError) return out;\n\n      if (!error || (error && out.index > error.index)) {\n        error = out;\n      }\n    }\n\n    return error;\n  });\n};\n\n//           between :: Parser e a s -> Parser e b s -> Parser e c s -> Parser e b s\nexport const between = function between(leftParser) {\n  return function between$rightParser(rightParser) {\n    return function between$rightParser(parser) {\n      return sequenceOf ([\n        leftParser,\n        parser,\n        rightParser\n      ]) .map (([_, x]) => x);\n    }\n  }\n};\n\n//           everythingUntil :: Parser e a s -> Parser e String s\nexport const everythingUntil = function everythingUntil(parser) {\n  return new Parser(state => {\n    if (state.isError) return state;\n\n    const results = [];\n    let nextState = state;\n\n    while (true) {\n      const out = parser.p(nextState);\n\n      if (out.isError) {\n        const {index, target} = nextState;\n        const val = target[index];\n\n        if (val) {\n          results.push(val);\n          nextState = updateParserState(nextState, val, index + 1);\n        } else {\n          return updateError(nextState, `ParseError 'everythingUntil' (position ${nextState.index}): Unexpected end of input.`);\n        }\n      } else {\n        break;\n      }\n    }\n\n    return updateResult(nextState, results.join(''));\n  });\n};\n\n//           anythingExcept :: Parser e a s -> Parser e Char s\nexport const anythingExcept = function anythingExcept(parser) {\n  return new Parser(function anythingExcept$state(state) {\n    if (state.isError) return state;\n    const {target, index} = state;\n\n    const out = parser.p(state);\n    if (out.isError) {\n      return updateParserState(state, target[index], index + 1);\n    }\n    return updateError(state, `ParseError 'anythingExcept' (position ${index}): Matched '${out.result}' from the exception parser`);\n  });\n};\n\n//           lookAhead :: Parser e a s -> Parser e a s\nexport const lookAhead = function lookAhead(parser) {\n  return new Parser(function lookAhead$state(state) {\n    if (state.isError) return state;\n    const nextState = parser.p(state);\n    return (nextState.isError)\n      ? updateError(state, nextState.error)\n      : updateResult(state, nextState.result);\n  });\n};\n\n//           possibly :: Parser e a s -> Parser e (a | Null) s\nexport const possibly = function possibly(parser) {\n  return new Parser(function possibly$state(state) {\n    if (state.isError) return state;\n\n    const nextState = parser.p(state);\n    return (nextState.isError)\n      ? updateResult(state, null)\n      : nextState;\n  });\n};\n\n//           skip :: Parser e a s -> Parser e a s\nexport const skip = function skip(parser) {\n  return new Parser(function skip$state(state) {\n    if (state.isError) return state;\n    const nextState = parser.p(state);\n    if (nextState.isError) return nextState;\n\n    return updateResult(nextState, state.result);\n  });\n};\n\n//           endOfInput :: Parser e Null s\nexport const endOfInput = new Parser(function endOfInput$state(state) {\n  if (state.isError) return state;\n  const {target, index} = state;\n  if (index !== target.length) {\n    return updateError(state, `ParseError 'endOfInput' (position ${index}): Expected end of input but got '${target.slice(index, index+1)}'`);\n  }\n\n  return updateResult(state, null);\n});\n\n//           whitespace :: Parser e String s\nexport const whitespace = regex(reWhitespaces)\n  // Keeping this error even though the implementation no longer uses many1. Will change it to something more appropriate in the next major release.\n  .errorMap((_, index) => `ParseError 'many1' (position ${index}): Expecting to match at least one value`);\n\n//           optionalWhitespace :: Parser e String s\nexport const optionalWhitespace = possibly(whitespace).map(x => x||'');\n\n//           recursiveParser :: (() => Parser e a s) -> Parser e a s\nexport const recursiveParser = function recursiveParser(parserThunk) {\n  return new Parser(function recursiveParser$state(state) {\n    return parserThunk().p(state);\n  });\n};\n\n//           takeRight :: Parser e a s -> Parser f b t -> Parser f b t\nexport const takeRight = lParser => rParser => lParser.chain(() => rParser);\n\n//           takeLeft :: Parser e a s -> Parser f b t -> Parser e a s\nexport const takeLeft = lParser => rParser => lParser.chain(x => rParser.map(() => x));\n\n//           toPromise :: ParserResult e a s -> Promise (e, Integer, s) a\nexport const toPromise = result => {\n  return result.isError\n    ? Promise.reject({\n      error: result.error,\n      index: result.index,\n      data: result.data\n    })\n    : Promise.resolve(result.result);\n};\n\n//           toValue :: ParserResult e a s -> a\nexport const toValue = result => {\n  if (result.isError) {\n    const e = new Error(result.error);\n    e.parseIndex = result.index;\n    e.data = result.data;\n    throw e;\n  }\n  return result.result;\n};\n","function hueToRgb(p, q, t) {\n  if (t < 0) t += 1;\n  if (t > 1) t -= 1;\n  if (t < 1 / 6) return p + (q - p) * 6 * t;\n  if (t < 1 / 2) return q;\n  if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n  return p;\n}\n\nmodule.exports = hueToRgb;\n","var hueToRgb = require('./hueToRgb');\n\n/**\n * Convert a color from HSL to RGB\n *\n * @param {number} h - A value from 0 - 360\n * @param {number} s - A value from 0 - 100\n * @param {number} l - A value from 0 - 100\n * @returns {object} With the signature {r: 0-255, g: 0-255, b: 0-255}\n */\nfunction hslToRgb(h, s, l) {\n\n  h /= 360;\n  s /= 100;\n  l /= 100;\n\n  var r, g, b;\n\n  if (s === 0) {\n    r = g = b = l; // achromatic\n  } else {\n    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n    var p = 2 * l - q;\n    r = hueToRgb(p, q, h + 1 / 3);\n    g = hueToRgb(p, q, h);\n    b = hueToRgb(p, q, h - 1 / 3);\n  }\n\n  return ({\n    r: r * 255,\n    g: g * 255,\n    b: b * 255\n  });\n}\n\nmodule.exports = hslToRgb;\n","/**\n * Convert a color from RGB to hexidecimal\n *\n * @param {number} r - A value from 0 - 255\n * @param {number} g - A value from 0 - 255\n * @param {number} b - A value from 0 - 255\n * @returns {string} In the format #000000\n */\nfunction rgbToHex(r, g, b) {\n  var integer = ((Math.round(r) & 0xFF) << 16)\n    + ((Math.round(g) & 0xFF) << 8)\n    + (Math.round(b) & 0xFF);\n\n  var string = integer.toString(16).toUpperCase();\n  return '#' + ('000000'.substring(string.length) + string);\n}\n\nmodule.exports = rgbToHex;\n","var hslToRgb = require('./hslToRgb');\nvar rgbToHex = require('./rgbToHex');\n\nfunction hslToHex(h, s, l) {\n  var rgb = hslToRgb(h, s, l);\n  return rgbToHex(rgb.r, rgb.g, rgb.b);\n}\n\nmodule.exports = hslToHex;\n","var hslToHex = require('tie-dye/hslToHex');\n\nfunction hashbow(input, saturation, lightness) {\n\n  var inputAsString, sum;\n  saturation = saturation || 50;\n  lightness = lightness || 50;\n\n  var greyValues = [null, undefined, [], {}, '', new RegExp()];\n\n  if (greyValues.indexOf(input) != -1) {\n    return hslToHex(0, 0, lightness);\n  }\n\n  switch (input.constructor) {\n    case Function:\n    case RegExp:\n      inputAsString = input.toString();\n    break;\n    case Object:\n    case Array:\n      inputAsString = JSON.stringify(input);\n    break;\n    case Number:\n      sum = input;\n    break;\n    case Boolean:\n      return hslToHex(input ? 120 : 0, saturation, lightness);\n    break;\n    case String:\n    default:\n      inputAsString = input;\n  }\n\n  if (sum === undefined) {\n    sum = 0;\n    inputAsString.split('').forEach(function (letter) {\n      sum += letter.charCodeAt(0);\n    });\n  }\n\n  sum = Math.abs(sum * sum);\n\n  return hslToHex(sum % 360, saturation, lightness);\n}\n\nmodule.exports = hashbow;\n","import { h, app } from \"hyperapp\"\nimport * as A from \"arcsecond\"\nimport hashbow from \"hashbow\"\n\nconst positiveNumber = A.digits.map(parseInt)\n\nconst number = A.coroutine(function*() {\n    const sign = (yield A.possibly(A.choice([ A.char(\"+\"), A.char(\"-\") ]))) || \"+\"\n    const number = yield A.digits\n    return parseInt(sign + number)\n})\n\n// Parse a \"dice notation\" string like \"3d6+7\"\nconst diceNotationParser = A.coroutine(function*() {\n    const numDice = (yield A.possibly(positiveNumber)) || 1 // Optionally parse the bit before the \"d\" - number of dice\n    const modeChar = yield A.choice([A.char(\"d\"), A.char(\"u\")])\n    const die = yield positiveNumber // Parse the number indicating the number of sides on the simulated di(c)e\n    const offset = (yield A.possibly(number)) || 0 // Optionally parse an offset - the \"number\" parser happens to handle positives/negatives, so it works without any extra logic\n    return { numDice, die, offset }\n})\n\nconst roll = ({ numDice, die, offset }) => {\n    let sum = offset\n    for (let i = 0; i < numDice; i++) {\n        sum += Math.floor(Math.random() * die) + 1\n    }\n    return sum\n}\n\nconst simpleDistribution = dieSize => {\n    const dist = new Map()\n    for (let i = 1; i <= dieSize; i++) {\n        dist.set(i, 1 / dieSize)\n    }\n    return dist\n}\n\nconst addDistributions = (x, y) => {\n    const dist = new Map()\n    for (const [xResult, xProbability] of x) {\n        for (const [yResult, yProbability] of y) {\n            const result = xResult + yResult\n            dist.set(result, (dist.get(result) || 0) + (xProbability * yProbability))\n        }\n    }\n    return dist\n}\n\nconst offsetDistribution = (dist, offset) => {\n    const newDist = new Map()\n    for (const [result, probability] of dist) {\n        newDist.set(result + offset, probability)\n    }\n    return newDist\n}\n\nconst stats = ({ numDice, die, offset }) => {\n    const lowerBound = numDice + offset\n    const upperBound = numDice * die + offset\n    const oneDieProbabilities = simpleDistribution(die)\n    let probabilities = oneDieProbabilities\n    for (let i = 1; i < numDice; i++) {\n        probabilities = addDistributions(probabilities, oneDieProbabilities)\n    }\n    probabilities = offsetDistribution(probabilities, offset)\n    return { upperBound, lowerBound, probabilities }\n}\n\nconst percentage = value => `${(value * 100).toFixed(1)}%`\n\nconst renderDistribution = dist => {\n    let elements = []\n    let highest = 0\n    for (const [_, value] of dist) {\n        if (value > highest) {\n            highest = value\n        }\n    }\n\n    let i = 0\n    for (const [result, probability] of dist) {\n        const fraction = probability / highest\n        elements.push(h(\"rect\", { \n            x: i * 50, \n            y: 100 - fraction * 100, \n            width: 49, \n            height: fraction * 100, \n            style: { fill: `rgb(0, 0, ${255 * fraction})` } }, \n        [ h(\"title\", {}, percentage(probability)) ]))\n\n        elements.push(h(\"text\", { x: i * 50 + 25, y: 120, width: 50, \"text-anchor\": \"middle\" }, result))\n        i++\n    }\n    return h(\"svg\", { height: 130, width: i * 50 + 50, class: \"distribution\" }, elements)\n}\n\nconst rollButton = state => {\n    if (state.dice === null) {\n        return { ...state, rolls: [] }\n    } else {\n        return { ...state, rolls: [{ result: roll(state.dice), dice: state.dice }].concat(state.rolls).slice(0, 50) }\n    }\n}\n\nconst updateDice = (state, text) => {\n    const result = diceNotationParser.run(text)\n    console.log(result)\n    if (result.isError) {\n        return { ...state, rawDice: text, error: result.error, dice: null }\n    } else {\n        result.result.stats = stats(result.result)\n        result.result.raw = text\n        return { ...state, rawDice: text, error: null, dice: result.result }\n    }\n}\n\nconst renderRoll = roll => {\n    const rawDice = roll.dice.raw\n    return h(\"tr\", {}, [\n        h(\"td\", { class: \"raw-dice\", style: { color: hashbow(rawDice) }, onClick: state => updateDice(state, rawDice) }, rawDice),\n        h(\"td\", { class: \"result\" }, roll.result),\n        h(\"td\", { class: \"outcome-probability\" }, percentage(roll.dice.stats.probabilities.get(roll.result)))\n    ])\n}\n\nconst onDiceInput = (state, event) => updateDice(state, event.target.value)\n\napp({\n    init: updateDice({ rolls: [] }, \"d6\"),\n    view: state =>\n      h(\"div\", {}, [\n        h(\"div\", { class: \"controls\" }, [\n            h(\"input\", { type: \"text\", value: state.rawDice, onInput: onDiceInput }),\n            h(\"button\", { onClick: rollButton, class: \"roll-button\" }, \"Roll\"),\n        ]),\n        state.error !== null ? h(\"div\", { class: \"error\" }, state.error) : null,\n        state.dice && state.dice.stats && state.dice.stats.probabilities && renderDistribution(state.dice.stats.probabilities),\n        state.rolls.length > 0 ? h(\"h1\", {}, state.rolls[0].result) : null,\n        h(\"table\", { class: \"previous-rolls\" }, [\n            h(\"tr\", {}, [ h(\"th\", {}, \"Dice\"), h(\"th\", {}, \"Result\"), h(\"th\", {}, \"Chance\") ])\n        ].concat(state.rolls.map(renderRoll)))\n    ]),\n    node: document.getElementById(\"app\")\n})"]}